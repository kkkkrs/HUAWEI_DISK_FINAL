## 4.14

### 第一轮

不知道预处理数据，需要对每种tag都划分一定的区域

#### 对于tag为0的对象
* 划分一定的区域可以直接进行抛弃

* 随机插入前面的tag区域中 （感觉不太好,需要衡量为0的对象占比）

#### 如何在第一轮进行提前报busy
* 不能每个period进行区域放弃

* 如果直接抛弃掉tag为0的对象，很有可能会导致没有东西读

* 似乎可以根据当前的负载情况一点一点开放tag为0的区域，但是很有可能导致请求过期延时

#### 第一轮需要对第二轮记录的信息

对于tag为0的对象
* 记录每一次请求的timestamp

对于tag不为0的对象
* 记录一下该tag对应的每次请求的timestamp

每个对象都需要记录创建时间、删除时间、size大小

### 第二轮

#### 如何划分tag的区域以及tag排序
* 计算每一个tag的对象数量峰值？

* 似乎可以不需要直接划分tag的起点和终点，只需要知道该tag的中心在哪里就可以了

* 对于tag区域内部，可以优先根据对象删除时间，然后将删除时间早的放在tag区域的两侧

* tag排序需要注意要在保证读取趋势相同的同时尽量不要让写入趋势相似的放在一起了，这里的方案需要进行取舍

#### 如何进行提前报busy

初步想法

* 每过100个timestamp,可以统计每100个cell(或者可以动态地调整为一个tag的一个连续区域)的下一百个timestamp的读取数量除以cell数量
* 然后对每100个cell进行排序，可以使用同样的打日志方法来选择抛弃的区域数量
* 将该对象要不要拒绝访问直接写入对象中，每100个timestamp进行更新
* 如果这个时候有新的对象写入到了拒绝的区域中，应该如何找出这个对象要不要拒绝请求
* 通过查看周围的对象是否被拒绝?
