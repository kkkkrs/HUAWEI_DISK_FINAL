### TODOLIST

* 优化垃圾回收，希望一次可以回收两个
* round1中途就进行预测，使用垃圾回收移回去
* 第二轮的tag计算读取密度计算实时的区域读取密度，然后进行放弃
* 第一轮也根据上900个时间片的读取密度来放弃区域


## 4.14

### 第一轮

不知道预处理数据，需要对每种tag都划分一定的区域

#### 对于tag为0的对象
* 划分一定的区域可以直接进行抛弃

* 随机插入前面的tag区域中 （感觉不太好,需要衡量为0的对象占比）

#### 如何在第一轮进行提前报busy
* 不能每个period进行区域放弃

* 如果直接抛弃掉tag为0的对象，很有可能会导致没有东西读

* 似乎可以根据当前的负载情况一点一点开放tag为0的区域，但是很有可能导致请求过期延时

#### 第一轮需要对第二轮记录的信息

对于tag为0的对象
* 记录每一次请求的timestamp

对于tag不为0的对象
* 记录一下该tag对应的每次请求的timestamp

每个对象都需要记录创建时间、删除时间、size大小

### 第二轮

#### 如何划分tag的区域以及tag排序
* 计算每一个tag的对象数量峰值？

* 似乎可以不需要直接划分tag的起点和终点，只需要知道该tag的中心在哪里就可以了

* 对于tag区域内部，可以优先根据对象删除时间，然后将删除时间早的放在tag区域的两侧

* tag排序需要注意要在保证读取趋势相同的同时尽量不要让写入趋势相似的放在一起了，这里的方案需要进行取舍

* 每次写入都选择该tag最少的磁盘进行写入，而不是用之前的方法

#### 如何进行提前报busy

初步想法

* 每过100个timestamp,可以统计每100个cell(或者可以动态地调整为一个tag的一个连续区域)的下一百个timestamp的读取数量除以cell数量
* 然后对每100个cell进行排序，可以使用同样的打日志方法来选择抛弃的区域数量
* 将该对象要不要拒绝访问直接写入对象中，每100个timestamp进行更新

如果这个时候有新的对象写入到了拒绝的区域中，应该如何找出这个对象要不要拒绝请求
通过查看周围的对象是否被拒绝?


## 4.15

### 第一轮写入
* 首先把对tag进行排序,然后把磁盘的30%-40%分给各个有tag的
* 每一个tag区域也是从中间向两边写，如果空间不够，可以在其他tag中进行交错
* 对于tag为0的对象，可以选择从磁盘的65%区域向两边写
* 根据每一个period或者每1000个时间片，切换一下放弃磁盘tag为0的区域的百分比，使用打日志的方式计算最佳占比

### 第一轮如何提前报busy
* 在一个period开始的时候
* 对于tag不为0的区域，统计这些区域的分别请求数量
* 对于tag为0的区域，将区域分为5-10份，然后依据请求数量除以单元格的数量进行排序
* 在每个period的TIMESTAMP为100-300时进行busy_area_num的切换